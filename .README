# Drizzle Kit - Migrations e Studio
(Configurações do Drizzle ORM)

Este projeto utiliza o [Drizzle Kit](https://github.com/Drizzle-Team/drizzle-kit) para gerenciar migrações e interagir com o banco de dados através de uma interface gráfica (UI).

## Scripts no `package.json`

O `package.json` contém alguns scripts para facilitar o uso do Drizzle Kit. Abaixo estão os detalhes de cada um deles:

### 1. `db:generate`
```bash
"db:generate": "drizzle-kit generate"

"Descrição": Este comando faz a leitura dos esquemas (schemas) definidos no seu projeto e gera os arquivos SQL necessários para a criação ou modificação das tabelas no banco de dados.
"Uso": Utilize este comando para gerar as migrações quando houver mudanças nos esquemas de banco de dados.
```

### 2. `db:migrate`
```bash
"db:migrate": "drizzle-kit migrate"

"Descrição": Este comando executa os arquivos SQL gerados pelo db:generate no banco de dados, aplicando as migrações e criando ou alterando as tabelas conforme necessário.
"Uso": Execute este comando para aplicar as migrações no seu banco de dados.
```

### 3. `db:studio`
```bash
"db:studio": "drizzle-kit studio"

"Descrição": Este comando inicia a interface gráfica (UI) do Drizzle Kit, permitindo que você interaja visualmente com o seu banco de dados. A UI facilita a visualização e edição das tabelas, registros e outros aspectos do banco de dados.
"Uso": Execute este comando para abrir a UI do Drizzle e gerenciar seu banco de dados de forma visual.
```

-------

# transform-swagger-schema.ts
(Rota: Upload de imagem)
### "Descrição":

A função `transformSwaggerSchema` altera a formatação de `application/json` do requestBody para multipart/form-data para que arquivos possam ser enviados na requisicao.

A rota upload-images.ts também necessita de alterações, tendo em vista que no `schema` da rota nao utilizamos `body` mais e consumimos o formato `multipart/form-data` para que arquivos possam ser usados no momento da requisição FE -> BE. No retorno da da rota, definimos alguns parametros que formatam a dimensão do arquivo:
  ```
  const uploadedFile = await request.file({
      limits: {
        fileSize: 1024 * 1024 * 2, // 2mb
      },
    })
  ```

### toBuffer vs streams:
(upload-image.ts)


O método `toBuffer()` carrega todos os dados do arquivo, guardando a representação desse arquivo em memória. Em suma, quando fazemos o armazenamento do arquivo com esse método, devemos considerar a dimensão e escalabilidade do projeto, vide que o processamento integral dos dados do arquivo podem criar um gargalo em performance.
Ex: Se 10000 pessoa fazem upload de uma unica imagem de 2mb de tamanho ao mesmo tempo, teriamos 20gb de memória ram necessária somente para armazenar esses arquivos.
```
const file = await uploadFile.toBuffer()
```

Quando o FE faz a requisicao para o BE, enquanto o FE envia a requisicao, o BE começa a processar essa imagem enviando ela também para um serviço terceiro como cloudFlare, aws3, ou seja, guardamos em memória apenas pequenos pedaços da imagem que serão carregados para dentro dos serviços.
A tipagem do arquivo como `['multipart/form-data']` sugere que a leitura dos dados é feita em pequenos pedaços, diferentemente de `application/json`.
```
  await uploadImage({
    fileName: uploadedFile.filename,
    contentType: uploadedFile.mimetype,
    contentStream: uploadedFile.file,
  })
```

### Shared/Either.ts
#### Functional Error Handling

Quando tratamos erros, normalmente usamos o bloco `try&catch`, porém por node nao ser uma linguagem funcional, o tratamento de errors em questão deixa a desejar quando é necessário maior definição nas tratativas.
Em linguagens como Go/Elixir, por exemplo, cada função assíncrona retorna dois possiveis valores, `[error, result]`.

Para termos o mesmo padrão na aplicação, podemos usar as utility functions documentadas no arquivo `either.ts`, onde temos `left` e `right`, onde o primeiro é erro e o segundo é sucesso.

Na funcão de upload-image (src/app/functions/upload-image.ts), declaramos o retorno dela como:
```
Promise<Either<InvalidFileFormat, { url: string }>>
```
Sendo o retorno de error (InvalidFileFormat) ou o retorno de sucesso dela como { url: string }, utilizando as utility functions `makeLeft (error)` e `makeRight (success)`

Na rota de upload-image (src/infra/http/routes/upload-image.ts) utilizamos as utility functions `unwrapEither` e `isRight` para definir corretamente o retorno da rota.

`isRight` é declarado inicialmente e, caso os valores atinjam essa condição, retornaremos a resposta com o status 201. Se o valor for erro, então a condição isRight será pulada e caíremos na tratativa de error com `unwrapEither`, onde o resultado já é erro e as utility functions terão tipado corretamente os valores.

```
  async (request, reply) => {
    const uploadedFile = await request.file({
      limits: {
        fileSize: 1024 * 1024 * 2, // 2mb
      },
    })

    if (!uploadedFile) {
      return reply.status(400).send({ message: 'File is required.' })
    }

    const result = await uploadImage({
      fileName: uploadedFile.filename,
      contentType: uploadedFile.mimetype,
      contentStream: uploadedFile.file,
    })

    // Success
    if (isRight(result)) {
      return reply.status(201).send()
    }

    // Error
    const error = unwrapEither(result)
    switch (error.constructor.name) {
      case 'InvalidFileFormat':
        return reply.status(400).send({ message: error.message })
    }
  }
```
